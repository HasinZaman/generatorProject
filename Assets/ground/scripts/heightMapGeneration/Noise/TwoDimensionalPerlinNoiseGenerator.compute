#pragma kernel noiseCalc

/// <summary>
///     BINARYPOSTOINDEX turns a binary position into a index
/// </summary>
/// <return>
///     the index of a converted pos
/// </return>
#define BINARYPOSTOINDEX(x,y) (x+y*2)

/// <summary>
///     PI is a constant for pi ;)
/// </summary>
#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679

/// <summary>
///     perlinVectors is a texture that contains the vectors used to generate perlin noise
/// </summary>
StructuredBuffer<float> perlinVectors;

/// <summary>
///     perlinVectorsDim stores the dim of perlinVectors
/// </summary>
StructuredBuffer<uint> perlinVectorsDim;

/// <summary>
///     output is the texture that will store the final noise
/// </summary>
RWStructuredBuffer<float> output;

/// <summary>
///     outputDim stores the dim of output
/// </summary>
StructuredBuffer<uint> outputDim;

/// <summary>
///     cosineInterpolate gets the interoplated value between two numbers points
/// </summary>
/// <return>
///     float of the interpolated value between two points
/// </return>
float cosineInterpolate(float y1, float y2, float intermediaryPoint)
{
    float mu = (1 - cos(intermediaryPoint * PI)) / 2;

    return y1 * (1 - mu) + y2 * mu;
}

/// <summary>
///     dotProduct calculates the dotproduct of two vectors
/// </summary>
/// <return>
///     dotproduct of two vectors
/// </return>
float dotProduct(float2 vectors, float2 dist)
{
    return vectors.x * dist.x + vectors.y * dist.y;
}

/// <summary>
///     noiseCalc calculates the noise value a numerious points by modifing noise texture
/// </summary>
[numthreads(10, 10, 1)]
void noiseCalc(uint3 id : SV_DispatchThreadID)
{
    float2 pointDist[4];
    float2 pointVector[4];
    float pointValue[4];
    
    float sample;
    
    float2 pos = float2(
            float(id.x) / float(outputDim.Load(0)) * float(perlinVectorsDim.Load(0)),
            float(id.y) / float(outputDim.Load(1)) * float(perlinVectorsDim.Load(1))
        );
    output[0] = outputDim.Load(0);
    return;
    /*if (pos.x >= outputDim.Load(0) || pos.y >= outputDim.Load(1))
    {
        return;
    }*/
    
    pointDist[BINARYPOSTOINDEX(0, 0)] = float2(pos.x % 1, pos.y % 1);
    pointDist[BINARYPOSTOINDEX(1, 0)] = float2(pos.x % 1 - 1, pos.y % 1);
    pointDist[BINARYPOSTOINDEX(0, 1)] = float2(pos.x % 1, pos.y % 1 - 1);
    pointDist[BINARYPOSTOINDEX(1, 1)] = float2(pos.x % 1 - 1, pos.y % 1 - 1);
    
    //gets the dot product for every corner
    pointVector[BINARYPOSTOINDEX(0, 0)] =
        float2(
            perlinVectors[int(floor(pos.x) + floor(pos.y) * perlinVectorsDim.Load(0))],
            perlinVectors[int(floor(pos.x) + floor(pos.y) * perlinVectorsDim.Load(0)) + 1]
        );
    pointVector[BINARYPOSTOINDEX(1, 0)] =
        float2(
            perlinVectors[int(ceil(pos.x) + floor(pos.y) * perlinVectorsDim.Load(0))],
            perlinVectors[int(ceil(pos.x) + floor(pos.y) * perlinVectorsDim.Load(0)) + 1]
        );
    pointVector[BINARYPOSTOINDEX(0, 1)] =
        float2(
            perlinVectors[int(floor(pos.x) + ceil(pos.y) * perlinVectorsDim.Load(0))],
            perlinVectors[int(floor(pos.x) + ceil(pos.y) * perlinVectorsDim.Load(0))] + 1);
    pointVector[BINARYPOSTOINDEX(1, 1)] =
        float2(
            perlinVectors[int(ceil(pos.x) + ceil(pos.y) * perlinVectorsDim.Load(0))],
            perlinVectors[int(ceil(pos.x) + ceil(pos.y) * perlinVectorsDim.Load(0)) + 1]
        );
    
    for (int i1 = 0; i1 < 4; i1++)
    {
        pointVector[i1] = pointVector[i1] * 2 - float2(1, 1);
    }
    
    for (int x = 0; x < 2; x++)
    {
        for (int y = 0; y < 2; y++)
        {
            pointValue[BINARYPOSTOINDEX(x, y)] = dotProduct(pointVector[BINARYPOSTOINDEX(x, y)], pointDist[BINARYPOSTOINDEX(x, y)]);
        }
    }
    // gets the interpolated value using the dot products
    
    // p(0,1) --- Line 1 --- P(1,1)
    //              |
    //            line 2
    //              |
    // p(0,0) --- Line 0 --- P(1,0)
    float line0Val = cosineInterpolate(
            pointValue[BINARYPOSTOINDEX(0, 0)],
            pointValue[BINARYPOSTOINDEX(0, 1)],
            pos.x % 1
        );

    float line1Val = cosineInterpolate(
            pointValue[BINARYPOSTOINDEX(0, 1)],
            pointValue[BINARYPOSTOINDEX(1, 1)],
            pos.x % 1
        );

    float line2Val = cosineInterpolate(
            line0Val,
            line1Val,
            pos.y % 1
        );

    //output[id.x + id.y * outputDim.Load(0)] = id.x + id.y * outputDim.Load(0);
}